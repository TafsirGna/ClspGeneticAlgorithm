\chapter{Annexe 1}

\section{Classes et implémentation}
	
	Nous présentons ici la structure et quelques classes du programme (HFC-PGA) et nous détaillons les codes de quelques fonctions utilisées.
	
	\subsection{Classes}
	
	\begin{lstlisting}[language=python]
	#Classe représentant un chromosome	
	
class Chromosome(object):

	mutationRate = 0
	problem = 0
	hashTable = {}

	# Builder 
	def __init__(self):
		# Fonction d'initialisation de chromosome
	
	def init2(self, solution, itemsRank):
		# Autre fonction d'initialisation de chromosome
	
	def __lt__(self, chromosome):
		# Fonction utilisée dans le comparaison entre deux chromosomes
	
	def _get_fitnessValue(self):
		# Fonction de calcul du fitness d'un chromosome
	
	def _get_solution(self):
		# Fonction de récupération du genotype d'un chromosome
	
	def _get_itemsRanks(self):
		# Fonction de récupération de la période de satisfaction d'une production
	
	def _get_hashSolution(self):
		# Fonction de récupération du hash du génotype
	
	def _set_hashSolution(self, new_value):
		# Fonction d'attribution du hash d'un genotype
	
	def _set_itemsRanks(self, new_value):
		# Fonction d'attribution de la liste des rangs des productions
	
	def _set_solution(self, new_solution):
		# Fonction d'attribution du genotype d'un chromosome
	
	def _set_fitnessValue(self, new_value):
		# Fonction d'attribution de la valeur de fitness a un chromosome
	
	def __repr__(self):
		# Fonction d'affichage d'un chromosome
	
	def __eq__(self, chromosome):
		# Fonction utilisée dans le comparaison entre deux chromosomes
	
	def __ne__(self, chromosome):
		# Fonction utilisée dans le comparaison entre deux chromosomes
	
	def isFeasible(self):
		# Fonction de vérification de la faisabilité d'un chromosome
	
	def mutate(self):
		# Fonction utilisée afin de faire muter un chromosome
	
	def advmutate(self):
		# Fonction utilisée comme fonction de recherche locale
	
	def getFeasible(self):
		# Fonction utilisée afin de rendre faisable un chromosome
	
	def getCostof(cls, indice, item, rank,solution, secondIndice = -1):
		# Fonction de détermination du cout d'un gene dans le génotype d'un chromosome
	
	# Class' methods
	getCostof = classmethod(getCostof)

	# Properties
	solution = property(_get_solution,_set_solution)
	fitnessValue = property(_get_fitnessValue,_set_fitnessValue)
	itemsRank = property(_get_itemsRanks, _set_itemsRanks)
	hashSolution = property(_get_hashSolution, _set_hashSolution) 

    \end{lstlisting}
    
    \begin{lstlisting}[language=python]
    // Classe représentant un thread principal en HFC-PGA
    
class ClspThread(Thread):

	listMainThreads = 0
	NumberOfMigrants = 0
	NbGenToStop = 0
	crossOverRate = 0
	MigrationRate = 0
	NbMaxPopulation = 0
	FITNESS_PADDING = 0

	def __init__(self, threadId):
		# Constructeur de la classe	
	
	def run(self):
		# Fonction d'exécution du thread	
	
	def getPopImproved(self):
		# Fonction utilisée dans l'amélioration de la qualité de la population initiale	
	
	def exploit(self, chromosome):
		# Fonction utilisée afin d'exploiter un chromosome apres exploration 
		
	def initSearch(self, queue, parameter = "main"):
		# Fonction d'execution de la formation de la population initiale	
	
	def sendMigrants(self):
		# Fonction utilisee afin d'envoyer des chromosomes aux threads voisins	
	
	def receiveMigrants(self, chromosomes):
		# Fonction utilisee dans la reception des chromosomes de threads voisins	
	
	def replace(self, chromosome):
		#Code de la fonction ici	
	
	def getFitnessData(self):
		# Fonction utilisee dans la procedure de Roulette Wheel	
	
	def mate(self, chromosome1, chromosome2):
		# Fonction utilisee afin de reproduire deux chromosomes	
	
	def crossover(self, randValue1, randValue2):
		# Fonction utilisee dans le croisement de deux chromosomes
	
	def crossPopulation(self):
		# Fonction utilisee afin de lancer le croisement a travers toute la population	

	def insert(self, chromosome):
		# Fonction utilisee afin d'inserer un chromosome dans la population initiale	
		
		
    \end{lstlisting}
    
    \begin{lstlisting}[language=python]
class GeneticAlgorithm:

	#	Class' variables
	NbMaxPopulation = 25
	mutationRate = 0.05
	crossOverRate = 0.80
	FITNESS_PADDING = 1
	NumberOfMigrants = 1
	MigrationRate = 0 
	nbMainThreads = 3
	nbSlavesThread = 3
	NbGenToStop = 7

	# Builder
	def __init__(self, inst):
		# Constructeur de la classe
	
	def start(self):
		# Fonction utilisée afin de lancer l'exécution de l'algorithme génétique
	
	def printResults(self):
		# Fonction utilisée afin d'afficher les résultats
		
    \end{lstlisting}
	
	\subsection{Fonctions}	
	
	\begin{lstlisting}[language=python]
	# Fonction d'évaluation d'un chromosome
	
def evaluate(cls, sol):
			
		solution = list(sol)

		fitnessValue = 0
		# Calculation of all the change-over costs
		itemsRank = [1] * Chromosome.problem.nbItems
		i = 0
		for gene in solution:
			#print("gene : ", gene, " cost : ", Chromosome.getCostof(i, gene, itemsRank[gene-1], solution))
			fitnessValue += Chromosome.getCostof(i, gene, itemsRank[gene-1], solution)
			if gene != 0:
				itemsRank[gene-1] += 1
			i += 1

return fitnessValue		
    \end{lstlisting}	
	
		\begin{lstlisting}[language=python]
		# Fonction de faisabilité d'un chromosome
		
def getFeasible(self):

		#print(" In Chromosome 1 : ", self._solution)
		#print(self._solution)

		#if self.isFeasible() is False:

		#print(" grid : ", grid)
		copy_solution = list(self._solution)

		# i make sure that the number of goods producted isn't superior to the number expected
		i = 0
		while i < Chromosome.problem.nbTimes:

			if self._solution[i] != 0:

				item = self._solution[i]
				#print(" ok : ", self._solution, self._itemsRank)
				#print(" item picked : ", item)
				rank = self._itemsRank[i]
				#print(i, item-1, rank-1, self.manufactItemsPeriods)
				value = self.manufactItemsPeriods[item-1][rank-1]

				if value == -1:
					itemDemandPeriods = self.manufactItemsPeriods[item-1]
					itemDemandPeriods[rank-1] = i
					#print(" It isn't yet in the tab")
					#print(" == -1 ", item, i, rank)

				else:

					#print(" != -1 ", item, i, rank)
					#print(" It is already in the tab")
					cost1 = Chromosome.getCostof(value, item, rank, copy_solution, i)
					cost2 = Chromosome.getCostof(i, item, rank, copy_solution, value)

					#print(" cost 1 : ", cost1, " cost2 : ", cost2)
					if cost2 < cost1 :
						itemDemandPeriods = self.manufactItemsPeriods[item-1]
						itemDemandPeriods[rank-1] = i

						#print(" cost2 < cost1 : ", value, item)
						self._solution[value] = 0

					else:
						self._solution[i] = 0
			i+=1

		#print(" in middle getFeasible : ", self._solution, ", ", self._itemsRank)
		#print()
		# i make sure that the number of items producted isn't inferior to the number expected
		i = 0
		while i < Chromosome.problem.nbItems:

			j = 0
			nbmanufactItemsPeriods = len(self.manufactItemsPeriods[i])
			while j < nbmanufactItemsPeriods:

				if self.manufactItemsPeriods[i][j] == -1:
					if j == 0:
						lbound = 0
					else:
						lbound = self.manufactItemsPeriods[i][j-1]
					
					zeroperiods = []
					k = lbound+1
					while k <= Chromosome.problem.deadlineDemandPeriods[i][j]:
						if self._solution[k] == 0:
							zeroperiods.append(k)
						k+=1

					#print("zeroperiods : ", zeroperiods)
					nbZeroPeriods = len(zeroperiods)

					if nbZeroPeriods > 0:

						cost1 = Chromosome.getCostof(zeroperiods[0], i+1, j+1, copy_solution)
						#print(" cost1 : ", cost1 )

						k = 1 
						indice = zeroperiods[0]
						while k < nbZeroPeriods:
							cost2 = Chromosome.getCostof(zeroperiods[k], i+1, j+1, copy_solution)
							#print(" cost2 : ", cost2 , zeroperiods[k])
							if cost2 < cost1:
								#print(" cost2 < cost1 : ", cost1 , cost2 )
								indice = zeroperiods[k]
							k+=1

						self._solution[indice] = i+1

						itemDemandPeriods = self.manufactItemsPeriods[i]
						itemDemandPeriods[j] = indice

					else:
						
						# experimental code 

						# if there's no place to put this item, then i check all the other times in order to put this item there
						
						lbound = 0
						p = 1
						for deadline in Chromosome.problem.deadlineDemandPeriods[i]:

							zeroperiods = []
							k = lbound
							while k <= deadline:
								if self._solution[k] == 0:
									zeroperiods.append(k)
								k += 1
							lbound = deadline + 1

							nbZeroPeriods = len(zeroperiods)
							if nbZeroPeriods > 0:

								cost1 = Chromosome.getCostof(zeroperiods[0], i+1, p, copy_solution)
								#print(" cost1 : ", cost1 )

								k = 1 
								indice = zeroperiods[0]
								while k < nbZeroPeriods:
									cost2 = Chromosome.getCostof(zeroperiods[k], i+1, p, copy_solution)
									#print(" cost2 : ", cost2 , zeroperiods[k])
									if cost2 < cost1:
										#print(" cost2 < cost1 : ", cost1 , cost2 )
										indice = zeroperiods[k]
									k+=1

								self._solution[indice] = i+1

								itemDemandPeriods = self.manufactItemsPeriods[i]
								itemDemandPeriods[j] = indice

bre
ak
							p += 1


				j+=1
			i+=1

    \end{lstlisting}
